<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" /> 
        <title>(λblog.rainbyte) - Haskell from 0 to IO (Maybe Hero)</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/highlight.css" />
    </head>
    <body>
        <header>
            <div id="logo">
                <a href="../">(λblog.rainbyte)</a>
            </div>
            <nav id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../cheatsheet.html">Cheatsheet</a>
                <a href="../posts.html">Archive</a>
                <a href="../atom.xml">Feed</a>
            </nav>
        </header>

        <section id="content">
            <h1>Haskell from 0 to IO (Maybe Hero)</h1>
            <div class="info">
    Posted on August 28, 2020
    
        by rainbyte
    
</div>

<div class="info">
    
        Tags: <a title="All pages tagged 'haskell'." href="../tags/haskell.html">haskell</a>, <a title="All pages tagged 'io'." href="../tags/io.html">io</a>, <a title="All pages tagged 'monad'." href="../tags/monad.html">monad</a>, <a title="All pages tagged 'typeclasses'." href="../tags/typeclasses.html">typeclasses</a>
    
</div>

<h2 id="introduction">Introduction</h2>
<p>This guide references some syntax and patterns used when writing programs
in the Haskell language. A text editor and the GHC compiler are required
to run the code, but online environments are also an option.</p>
<h2 id="minimal-example">Minimal example</h2>
<p>Haskell expects programs have an entrypoint called <code>main</code>, which later is
explained in detail, but for now we will create a file named <code>Program.hs</code>
and write inside the following code:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Comments are written like this</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="st">&quot;hola&quot;</span></span></code></pre></div>
<p>Check if code can be interpreted:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">runghc</span> Program.hs</span></code></pre></div>
<p>Check if code can be compiled and executed:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">ghc</span> <span class="at">-o</span> Program Program.hs</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ex">./Program</span></span></code></pre></div>
<p>Some system also require to add the <code>-dynamic</code> option (eg. Arch Linux).</p>
<h2 id="definitions">Definitions</h2>
<p>Haskell definitions indicate a type with <code>::</code> and their value with <code>=</code>.</p>
<p>Here <code>num</code> is defined with type <code>Int</code> and value <code>9</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">num ::</span> <span class="dt">Int</span> <span class="co">-- type</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>num <span class="ot">=</span> <span class="dv">9</span>    <span class="co">-- definition</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> num</span></code></pre></div>
<p>The <code>=</code> symbol means equality in both ways, this means that <code>num</code> can be
replaced by <code>9</code> anywhere.</p>
<p>Detailed definitions are done using <code>let..in..</code>, which has a <code>let</code> section
with local values accessed by the <code>in</code> section to calculate a final value.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>num <span class="ot">=</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x <span class="ot">=</span> <span class="dv">5</span>  <span class="co">-- define x</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        y <span class="ot">=</span> <span class="dv">10</span> <span class="co">-- define y</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> x <span class="op">+</span> y   <span class="co">-- use them</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> num</span></code></pre></div>
<p>Other way to have local definitions is to attach a <code>where</code> section, the
following code is equivalent to the previous one:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>num <span class="ot">=</span> x <span class="op">+</span> y <span class="co">-- use definitions</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    x <span class="ot">=</span> <span class="dv">5</span>  <span class="co">-- define x</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    y <span class="ot">=</span> <span class="dv">10</span> <span class="co">-- define y</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> num</span></code></pre></div>
<h2 id="types">Types</h2>
<p>Carefully designed types reject unwanted values by making them unrepresentable.</p>
<p>The <code>type</code> keyword indicates an alias to an existing type.</p>
<p>Here <code>String</code> is an alias to a list of <code>Char</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">String</span> <span class="ot">=</span> [<span class="dt">Char</span>]</span></code></pre></div>
<p>The <code>data</code> keyword is used to define custom types.</p>
<p>Booleans are represented in this way:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Bool</span> <span class="ot">=</span> <span class="dt">False</span> <span class="op">|</span> <span class="dt">True</span></span></code></pre></div>
<p>We can apply conditionals over booleans like this:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">b ::</span> <span class="dt">Bool</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>b <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="ot">s ::</span> <span class="dt">String</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>s <span class="ot">=</span> <span class="kw">if</span> b <span class="kw">then</span> <span class="st">&quot;True&quot;</span> <span class="kw">else</span> <span class="st">&quot;False&quot;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> s</span></code></pre></div>
<p>The <code>Ordering</code> type is used to compare things:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Ordering</span> <span class="ot">=</span> <span class="dt">LT</span> <span class="op">|</span> <span class="dt">EQ</span> <span class="op">|</span> <span class="dt">GT</span></span></code></pre></div>
<p>Handling each possible case for a type is called <code>pattern matching</code>, and
ideally all of them should be handled</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ord</span><span class="ot"> ::</span> <span class="dt">Ordering</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="fu">ord</span> <span class="ot">=</span> <span class="dt">LT</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="ot">s ::</span> <span class="dt">String</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>s <span class="ot">=</span> <span class="kw">case</span> <span class="fu">ord</span> <span class="kw">of</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">LT</span> <span class="ot">-&gt;</span> <span class="st">&quot;Less Than&quot;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="st">&quot;Equal&quot;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">GT</span> <span class="ot">-&gt;</span> <span class="st">&quot;Greater Than&quot;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> s</span></code></pre></div>
<p>The <code>Maybe</code> type is parametrized and represents the existence of something with
a generic type <code>t</code>, avoiding the use of <code>null</code> at all.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Maybe</span> t <span class="ot">=</span> <span class="dt">Nothing</span> <span class="op">|</span> <span class="dt">Just</span> t</span></code></pre></div>
<p><code>Pattern matching</code> also works with parametrized types:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mInt ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>mInt <span class="ot">=</span> <span class="dt">Just</span> <span class="dv">9</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="ot">num ::</span> <span class="dt">Int</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>num <span class="ot">=</span> <span class="kw">case</span> mInt <span class="kw">of</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> n  <span class="ot">-&gt;</span> n</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dv">0</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> num</span></code></pre></div>
<p>The <code>Either</code> type has 2 parameters and represents the existence of a value with
type <code>e</code> or a value with type <code>t</code>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Either</span> e t <span class="ot">=</span> <span class="dt">Left</span> e <span class="op">|</span> <span class="dt">Right</span> t</span></code></pre></div>
<p>We can use <code>Either String t</code> to represent an error message when a result of
type <code>t</code> cannot be obtained.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">err ::</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Int</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>err <span class="ot">=</span> <span class="dt">Left</span> <span class="st">&quot;Could not obtain the number&quot;</span></span></code></pre></div>
<h2 id="functions">Functions</h2>
<p>When we see an arrow <code>-&gt;</code> in a type, we know it is a function.</p>
<p>Every function receives an <code>a</code> and gives a <code>b</code> as result.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> a <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>Functions indicate their body with <code>=</code>.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>f x <span class="ot">=</span> x <span class="op">+</span> <span class="dv">3</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> (f <span class="dv">5</span>)</span></code></pre></div>
<p>The same function can be implemented inline as a lambda</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>f <span class="ot">=</span> \x <span class="ot">-&gt;</span> x <span class="op">+</span> <span class="dv">3</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> (f <span class="dv">5</span>)</span></code></pre></div>
<p>We can “combine” functions using the <code>.</code> operator, called <code>composition</code>, so
that if we have <code>g . f</code> then <code>f</code> will produce an intermediate result to be
taken by <code>g</code> to produce a final result:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>f x <span class="ot">=</span> x <span class="op">+</span> <span class="dv">3</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="ot">g ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>g x <span class="ot">=</span> x <span class="op">*</span> <span class="dv">5</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="ot">h ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>h <span class="ot">=</span> g <span class="op">.</span> f <span class="co">-- be careful with the order</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> (h <span class="dv">2</span>)</span></code></pre></div>
<p>There is also an <code>$</code> operator, called “application”, usually used to change
precedence and avoid extra parenthesis. You can think of it as having
parenthesis at both sides.</p>
<p>Here we have equivalent <code>main</code> implementations, choose the one you prefer.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>f x <span class="ot">=</span> x <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- all of these are equivalent</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>main1 <span class="ot">=</span> <span class="fu">print</span> <span class="op">.</span> f <span class="op">$</span> <span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>main2 <span class="ot">=</span> (<span class="fu">print</span> <span class="op">.</span> f) <span class="op">$</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>main3 <span class="ot">=</span> (<span class="fu">print</span> <span class="op">.</span> f) (<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>main4 <span class="ot">=</span> <span class="fu">print</span> (f (<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>))</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> main1</span></code></pre></div>
<p>A function can give a function as result and we can use this mechanism
to make new definitions:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>f x <span class="ot">=</span> \y <span class="ot">-&gt;</span> x <span class="op">+</span> y</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>add5 <span class="ot">=</span> f <span class="dv">5</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> (add5 <span class="dv">6</span>)</span></code></pre></div>
<p>Parenthesis in that type signature can be omitted, and we can also evaluate
the <code>f</code> function with all the parameters at once:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>f x <span class="ot">=</span> \y <span class="ot">-&gt;</span> x <span class="op">+</span> y</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> (f <span class="dv">5</span> <span class="dv">6</span>)</span></code></pre></div>
<p>We can also move the <code>y</code> parameter to the left side, just to make it easier
to read:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>f x y <span class="ot">=</span> x <span class="op">+</span> y</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> (f <span class="dv">5</span> <span class="dv">6</span>)</span></code></pre></div>
<p>A function can receive a function as parameter, but then those parenthesis
are required to maintain precedence. We don’t know what the <code>h</code> function
does, but we know it can be used over an <code>Int</code> like <code>3</code>.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">g ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>g h <span class="ot">=</span> h <span class="dv">3</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>f x <span class="ot">=</span> x <span class="op">+</span> <span class="dv">2</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> (g f) <span class="co">-- g consumes f function</span></span></code></pre></div>
<p><code>Pattern matching</code> can also be used to define a function piece-by-piece</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>fib <span class="dv">0</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>fib <span class="dv">1</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>fib x <span class="ot">=</span> fib (x <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> fib (x <span class="op">-</span> <span class="dv">2</span>)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> (fib <span class="dv">10</span>)</span></code></pre></div>
<h2 id="typeclasses">Typeclasses</h2>
<p>When types are generic, function body can only use known operations.</p>
<p>Here type <code>a</code> could be any type, so <code>x</code> can only be returned as-is.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">id' ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>id' x <span class="ot">=</span> x</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> (id' <span class="dv">5</span>)</span></code></pre></div>
<p>We can define a set of operations, then types could implement them,
that is called <code>typeclass</code>.</p>
<p>As example a type which fulfils the <code>Eq</code> typeclass will have all its
functions available.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    (==) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    (/=) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    (<span class="op">/=</span>) x y <span class="ot">=</span> <span class="fu">not</span> (x <span class="op">==</span> y)</span></code></pre></div>
<p>We can see that <code>Ord</code> needs <code>b</code> to implement <code>Eq</code>, because it needs
operations from that set.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Eq</span> b <span class="ot">=&gt;</span> <span class="dt">Ord</span> b <span class="kw">where</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    compare              ::</span> b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Ordering</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    (<span class="op">&lt;</span>), (<span class="op">&lt;=</span>), (<span class="op">&gt;=</span>),<span class="ot"> (&gt;) ::</span> b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">max</span>,<span class="ot"> min             ::</span> b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>Typeclass implementation is done via instances for each type.</p>
<p>Here we define <code>Eq</code> for the <code>Bool</code> type.</p>
<p>Remember that <code>(/=)</code> is already defined based on <code>(==)</code>.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    (<span class="op">==</span>) <span class="dt">True</span>  <span class="dt">True</span>  <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    (<span class="op">==</span>) <span class="dt">False</span> <span class="dt">False</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    (<span class="op">==</span>) _     _     <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<p>The type <code>t</code> implements <code>Ord</code> and <code>Num</code> typeclasses, so inside <code>isPositive</code>
we can use number and comparison operations over <code>x</code> value.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">isPositive ::</span> (<span class="dt">Ord</span> t, <span class="dt">Num</span> t) <span class="ot">=&gt;</span> t <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>isPositive x <span class="ot">=</span> <span class="fu">compare</span> <span class="dv">0</span> x</span></code></pre></div>
<h2 id="inputoutput">Input/Output</h2>
<p>Now we are ready to inspect the type of the <code>main</code> function we wrote at the
beginning.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="st">&quot;hola&quot;</span></span></code></pre></div>
<p>The <code>IO a</code> type represents a set of instructions that will be executed
by the runtime of Haskell, with something of type <code>a</code> as result.</p>
<p>In the case of main <code>a</code> is <code>()</code>, which is called <strong>unit</strong>, and its only
possible value is <code>()</code>.</p>
<p>This means that the <code>main</code> function produces a set of instructions to be
executed by the runtime when the program is launched.</p>
<p>We know that <code>print "hola"</code> type is also <code>IO ()</code> because it should have
the same type that <code>main</code> has to be valid code, and we also know that
<code>"hola"</code> is a <code>String</code>.</p>
<p>We could think that <code>print :: String -&gt; IO ()</code>, but we have been using
<code>print</code> with things of other types too, so its type should be something
like <code>C a =&gt; a -&gt; IO ()</code> with some unknown constraint C.</p>
<p>That constraint is the <code>Show</code> typeclass we can see here:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Show</span> a <span class="kw">where</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    show ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- plus other definitions</span></span></code></pre></div>
<p>Given that <code>show</code> function takes something and produces a <code>String</code>, then
that function is the missing piece.</p>
<p>Then we can infer that <code>print</code> type is <code>Show a =&gt; a -&gt; IO ()</code>, so <code>a</code>
is converted to an <code>String</code> which is printed.</p>
<p>This is the definition of the <code>print</code> function:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span><span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span> x <span class="ot">=</span> <span class="fu">putStrLn</span> (<span class="fu">show</span> x)</span></code></pre></div>
<p>As we can see, it uses <code>show</code> to obtain an <code>String</code>, which will be consumed
by the <code>putStrLn</code> function, and that is the one that has the <code>String -&gt; IO ()</code>
type we thought before.</p>
<p>We will see soon how to write bigger programs using <code>IO a</code> type, but first
we should talk a bit more about typeclasses.</p>
<h2 id="typeclass-laws">Typeclass Laws</h2>
<p>Some typeclasses define a set of associated laws which cannot be checked
by the compiler, but the code must follow them to preserve the logic.</p>
<p>Haskell relies on developers to check that their code adheres to the laws,
which could be done via mathematical proofs, but there are also tools to
generate informal tests to check properties (eg. QuickCheck).</p>
<p>We can take as example the <code>Eq</code> typeclass we saw before:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    (==) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    (/=) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
<p>A valid <code>Eq</code> implementation should follow these laws:</p>
<ul>
<li>Reflexivity: <code>x == x = True</code></li>
<li>Symmetry: <code>x == y = y == x</code></li>
<li>Transitivity: if <code>x == y &amp;&amp; y == z = True</code>, then <code>x == z = True</code></li>
<li>Substitution: if <code>x == y = True</code>, then <code>f x == f y = True</code></li>
<li>Negation: <code>x /= y = not (x == y)</code></li>
</ul>
<p>We can see that our previous <code>Eq Bool</code> instance follows <em>reflexivity</em> law,
because by definition agrees with <code>x == x</code> form:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">==</span>) <span class="dt">True</span>  <span class="dt">True</span>  <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>(<span class="op">==</span>) <span class="dt">False</span> <span class="dt">False</span> <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
<p>Given that our implementation is valid, we can always replace <code>x == x</code>
with <code>True</code> when we see it, which is useful to simplify our code.</p>
<p>Typeclass laws help us to refactor the code and make it better using known
properties.</p>
<h2 id="typeclass-examples">Typeclass Examples</h2>
<p>There are many typeclasses defined in the Haskell libraries, the <a href="https://wiki.haskell.org/Typeclassopedia">Typeclassopedia</a> is a good place to start learning more details
about the standard typeclasses, but I will mention here some of the most common
ones and their laws, just as reference, there is no need to memorize them now
because they will become familiar as time passes.</p>
<ol type="1">
<li><p><strong>Semigroup Typeclass</strong></p>
<p>Types which fulfil <code>Semigroup</code> api should implement <code>(&lt;&gt;)</code> function, also
called <code>append</code>.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Semigroup</span> a <span class="kw">where</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&lt;&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- other definitions...</span></span></code></pre></div>
<p>The following property, called <strong>associativity</strong>, should be true for
any valid <code>Semigroup</code> instance:</p>
<ul>
<li><code>(x &lt;&gt; y) &lt;&gt; z = x &lt;&gt; (y &lt;&gt; z)</code></li>
</ul>
<p>We can use <code>(&lt;&gt;)</code> function to take to things of the same type and produce
a combined result also of the same type.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>s1 <span class="ot">=</span> <span class="st">&quot;hola&quot;</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>s2 <span class="ot">=</span> <span class="st">&quot;mundo&quot;</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> (s1 <span class="op">&lt;&gt;</span> s2)</span></code></pre></div>
<p>Each <code>Semigroup</code> instance defines how those things are combined, in this
case <code>String</code> concatenation occurs.</p></li>
<li><p><strong>Functor Typeclass</strong></p>
<p>Types which fulfil <code>Functor</code> api implement <code>fmap</code> function.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> t <span class="kw">where</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t b</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- other definitions...</span></span></code></pre></div>
<p>The following properties should be true for any valid <code>Functor</code> instance:</p>
<ul>
<li><code>fmap id  ==  id</code></li>
<li><code>fmap (f . g)  ==  fmap f . fmap g</code></li>
</ul>
<p>We can use <code>fmap</code> over a parametrized type <code>t a</code> to apply a function
<code>a -&gt; b</code> which takes things of type <code>a</code> to produce things of type <code>b</code>.</p>
<p>Here <code>fmap</code> is applied over a parametrized <code>List Int</code> to apply <code>f</code> function
which will add 3 to each integer inside the list, obtaining a new list with
the same shape but new values.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="ot">xs ::</span> [<span class="dt">Int</span>]</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>xs <span class="ot">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>f x <span class="ot">=</span> x <span class="op">+</span> <span class="dv">3</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> (<span class="fu">fmap</span> f xs)</span></code></pre></div>
<p>Remember, <code>fmap</code> behavior depends on the specific parametrized type we are
working with, eg. in the case of data structures usually allows us to apply
a function over each element preserving the structure shape.</p></li>
<li><p><strong>Applicative Typeclass</strong></p>
<p>Types which fulfil <code>Applicative</code> api should implement the required functions
(ie. <code>pure</code>, <code>(&lt;*&gt;)</code>, etc) and must have a <code>Functor</code> instance as well, so
the <code>fmap</code> function will be available as well.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> t <span class="ot">=&gt;</span> <span class="dt">Applicative</span> t <span class="kw">where</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    pure ::</span> a <span class="ot">-&gt;</span> t a</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&lt;*&gt;) ::</span> t (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t b</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- other definitions...</span></span></code></pre></div>
<p>The following properties should be true for any <code>Applicative</code> instance:</p>
<ul>
<li><code>pure id &lt;*&gt; v = v</code></li>
<li><code>pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)</code></li>
<li><code>pure f &lt;*&gt; pure x = pure (f x)</code></li>
<li><code>u &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u</code></li>
</ul>
<p>The <code>pure</code> function is really useful when working with a parametrized type
<code>t a</code> (eg. <code>IO a</code>, <code>Maybe a</code>, etc) because it allows us to take something
of type <code>a</code> and generate a value of type <code>t a</code> in a predefined way.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">pure</span> ()</span></code></pre></div>
<p>This example shows a program which does nothing, but it is interesting
anyway because we can see how <code>pure</code> obtains a <code>IO a</code> from an <code>a</code>, which
in this case is the unit type.</p></li>
<li><p><strong>Monad Typeclass</strong></p>
<p>Any type which implements <code>Monad</code> will have a <code>(&gt;&gt;=)</code> operation, called
<code>bind</code>, it should also implement <code>Applicative</code> and <code>Functor</code> api as well,
so we also have the <code>pure</code> and <code>fmap</code> functions available for <code>Monad</code>
instances.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> m <span class="kw">where</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- other definitions...</span></span></code></pre></div>
<p>When we see <code>mf &gt;&gt;= k</code> we know <code>k</code> consumes something of type <code>a</code> obtained
from <code>mf</code> (because <code>mf :: m a</code> and <code>k :: (a -&gt; m b)</code>), so we can say <code>k</code> is
a <strong>continuation</strong>, because it could be the next piece to be executed.</p>
<p>Keep in mind that the following properties are required for any valid
<code>Monad</code> instance:</p>
<ul>
<li><code>pure a &gt;&gt;= k  =  k a</code></li>
<li><code>mf &gt;&gt;= pure = mf</code></li>
<li><code>mf &gt;&gt;= (\x -&gt; k x &gt;&gt;= h)  =  (mf &gt;&gt;= k) &gt;&gt;= h</code></li>
</ul>
<p>The <code>&gt;&gt;=</code> function is useful when we have something of a parametrized type
<code>t a</code> and we want to process the values of type <code>a</code> with the condition that
in the end we should produce something of type <code>t b</code>.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>f n <span class="ot">=</span> <span class="st">&quot;n = &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> n</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a><span class="ot">mInt ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>mInt <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> (mInt <span class="op">&gt;&gt;=</span> (<span class="fu">pure</span> <span class="op">.</span> f))</span></code></pre></div>
<p>In the example we have <code>mInt</code> of type <code>Maybe Int</code> and we would like to
process that <code>Int</code> with the function <code>f</code> to obtain an <code>String</code>, so we
use the bind function <code>&gt;&gt;=</code> to do handle this and give <code>pure . f</code> as
continuation, so it conforms with the expected type <code>Int -&gt; Maybe String</code>.</p>
<p>The parametrized type <code>Maybe a</code> has a bind implementation which is
intelligent enough to note that the <code>a</code> (ie. <code>Int</code>) doesn’t exist,
because <code>mInt</code> value is <code>Nothing</code>, so bind avoids calling <code>pure . f</code>
as the continuation expects the <code>Int</code> to be there.</p>
<p>We can se that <code>pure . f</code> uses <code>pure</code> to conform with <code>Int -&gt; Maybe Int</code>
type, and it could have consumed an <code>Int</code> if <code>mInt</code> had it
(eg. <code>mInt = Just 4</code>).</p>
<p>As we can see, bind mechanism and meaning are related to the parametrized
type which implements the <code>Monad</code> instance, so we need to understand that
type very well before learning about the inner working of a certain
typeclass instance.</p></li>
</ol>
<h2 id="do-notation">Do-notation</h2>
<p>Finally, as promised, we can see how to write bigger programs using <code>IO a</code>
type.</p>
<p>First we can see a piece of code which uses <code>(&gt;&gt;=)</code> operator to obtain a
<code>String</code> written by the user and then prints it to the console.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">getLine</span> <span class="op">&gt;&gt;=</span> <span class="fu">putStrLn</span></span></code></pre></div>
<p>We can rewrite it using an explicit parameter named <code>line</code>, which is produced
by <code>getLine</code> subroutine and passed to the continuation (remember that when we
see something like <code>mf &gt;&gt;= k</code>, then <code>k</code> is the continuation).</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">getLine</span> <span class="op">&gt;&gt;=</span> (\line <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> line)</span></code></pre></div>
<p>As this gets tiring really quickly, Haskell defines a special syntax called
<code>do-notation</code>, which we can use to write equivalent code in a more familiar
style.</p>
<p>Like in 2nd example <code>getLine</code> result is available as <code>line</code> value.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    line <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStrLn</span> line</span></code></pre></div>
<p>As a final example we have an imperative-style program which asks the user
for an input and then iterates over the elements of a list printing the
user input each time.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (forM_)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>xs <span class="ot">=</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">10</span>]</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>    line <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>    forM_ xs <span class="op">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>        <span class="fu">putStrLn</span> (line <span class="op">&lt;&gt;</span> <span class="fu">show</span> x)</span></code></pre></div>
<p>There are other ways to write this program, but this can feel familiar to
programmers which already know other languages.</p>


<div id="gh-comments-list">
</div>

<script type="text/javascript">
    // This is a self executing function
    var issueId = 6;
    var url = "https://github.com/rainbyte/rainbyte.github.io/issues/" + issueId;
    var api_url = "https://api.github.com/repos/rainbyte/rainbyte.github.io/issues/" + issueId + "/comments";
    (function() {
        // DOM is already available, now we can handle page elements
        var ghCommentsList = document.getElementById("gh-comments-list");

        var request = new XMLHttpRequest();
        request.open('GET', api_url, true);
        request.onload = function() {
            if (request.status >= 200 && request.status < 400) {
                // Request was successful, we can process the raw comments
                var comments = JSON.parse(request.responseText);
                var fragment = document.createDocumentFragment();
                var range = new Range();

                // Render comments section header
                fragment.appendChild(range.createContextualFragment(`
                    <div>
                        <b>Comments section</b> (visit the <b><a href='${url}'>issue</a></b> of this post to add one)
                    </div>
                `));

                // Render view of each comment
                comments.forEach(comment => {
                    var date = new Date(comment.created_at);
                    var renderedComment = range.createContextualFragment(`
                        <div class='gh-comment'>
                            <div class='gh-comment-header'>
                                <img src='${comment.user.avatar_url}'>
                                <div>
                                    <b><a href='${comment.user.html_url}'>${comment.user.login}</a></b> posted at <em>${date.toDateString()}</em>
                                </div>
                            </div>
                            <div class='gh-comment-body'>
                                ${comment.body}
                            </div>
                        </div>
                    `);
                    fragment.appendChild(renderedComment);
                });

                // Make changes visible by adding rendered nodes
                ghCommentsList.append(fragment);
            } else {
                // Request reached the target server, but it returned an error
                ghCommentsList.append("Comments are not available now.");
            }
        };
        request.onerror = function() {
            // There was a connection error of some sort
            ghCommentsList.append("Comments are not available now.");
        };
        request.send();
    })();
</script>

        </section>
        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
